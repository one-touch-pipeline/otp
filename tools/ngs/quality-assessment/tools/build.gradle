import com.google.gson.Gson
import java.text.DecimalFormat
import groovy.io.FileType
import junitx.framework.AssertionFailedError
import junitx.framework.FileAssert

apply plugin: 'groovy'
apply plugin: 'application'

// Properties related to data generation and comparison tasks
// Directory where the results generated by the application will be created
String resultsDir = "~/tmp/qa-test/output/"

// Root directory that contains representative data and generated Gold Standard data from the CO group set of scripts
String dataRepositoryDir = "STORAGE_ROOT/dmg/otp/test/qa-test/"

// Directory where the results produced by the CO group set of scripts at the cluster will be created
String latestOutputDir = "${dataRepositoryDir}/latest-co-output/"

// Directory where the (used version of the) set of scripts from the CO group to generate data are stored
String sourceCodeDir = "${dataRepositoryDir}/co-scripts/v1"

// Directory where representative bam (and corresponding bai) files that will serve as input (for both this aplication and CO set of scripts) are stored
String bamFilesDir = "${dataRepositoryDir}/bam-files/"

// Path to the "small" bam file used to test and run the application locally
String smallBamFilePath = "${bamFilesDir}/tumor_run121026_SN952_0117_BC19ADACXX_paired.bam.sorted.bam"

// main class
mainClassName = "de.dkfz.tbi.ngstools.qualityAssessment.QualityAssessmentStatistics"

buildscript {
    repositories {
        maven {
            url '$ARTIFACTORY_URL'
        }
    }
    dependencies {
        classpath group: 'junit-addons', name: 'junit-addons', version: '1.4'
        classpath group: 'gson', name: 'gson', version: '2.2.2'
    }
}

// TODO maybe possible to reuse this..
repositories {
    maven {
        url '$ARTIFACTORY_URL'
    }
}

dependencies {
    groovy group: 'org.codehaus.groovy', name: 'groovy-all', version: '1.8.6'
    compile group: 'gson', name: 'gson', version: '2.2.2'
    compile group: 'sam', name: 'sam', version: '1.78'
    compile group: 'org.hibernate', name: 'hibernate-validator', version: '5.0.1.Final'
    testCompile group: 'junit', name: 'junit', version: '4.+'
}

jar {
    manifest.mainAttributes("Main-Class" : mainClassName)
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
//    baseName = "genomeQA" // defaults to root directory
//    version = branchName()
}

/**
 * Runs the application locally on a small bam file
 * All previous results will be overwritten
 */
task runSmallBam(dependsOn: 'classes') << {
    "mkdir ${processedBamDir(smallBamFilePath, resultsDir)}".execute()
    List<String> params = [smallBamFilePath, smallBamFilePath + ".bai", fileParameters(smallBamFilePath, resultsDir).values(), numericalParameters(sourceCodeDir).values()].flatten()
    tasks.run.args = params
    tasks.run.execute()
}

/**
 * Generates aplication test data for all representative bam files (submitting the jobs to the cluster)
 * All previous results will be overwritten
 */
task generateTestData << {
    bamFilesToTest(bamFilesDir).each { String bamFilePath ->
        int memory = 2
        String javaMemory = "${memory}G"
        String javaParameters = "-XX:+CMSClassUnloadingEnabled -XX:+UseConcMarkSweepGC -Xms${javaMemory} -Xmx${javaMemory}"
        String pathToJar = jar.archivePath
        String cmd = "mkdir ${processedBamDir(bamFilePath, resultsDir)}\n"
        String baiFilePath = bamFilePath + ".bai"
        cmd += "java ${javaParameters} -jar ${pathToJar} ${bamFilePath} ${baiFilePath}"
        fileParameters(bamFilePath, resultsDir).values().each { String fileParameter ->
            cmd += " " + fileParameter
        }
        numericalParameters(sourceCodeDir).values().each { String numericParameter ->
            cmd += " " + numericParameter
        }
        String shellScriptFilePath = createShellScript("${resultsDir}/script.sh", cmd)
        String clusterWallTime = "50:00:00"
        String clusterMemory = "${memory * 1000}m"
        String jobName = bamFileName(bamFilePath)
        String outputMessageFilePath = "${resultsDir}/${jobName}.o"
        String errorMessageFilePath =  "${resultsDir}/${jobName}.e"
        String clusterSubmission = "qsub -l walltime=${clusterWallTime},mem=${clusterMemory} -o ${outputMessageFilePath} -e ${errorMessageFilePath} -N ${jobName} ${shellScriptFilePath}"
        clusterSubmission.execute()
        println "Submitted to cluster job ${jobName}"
    }
}

/**
 * Generates all Gold Standard data from the set of CO scripts for all representative bam files (submitting the jobs to the cluster)
 * It deletes all previous generated data
 */
task generateGoldStandardData << {
    // delete all previous generated data but the readme file
    new File(latestOutputDir).eachFileRecurse { File file ->
        if (file.isDirectory()) {
            file.deleteDir()
        } else if (file.getName() != "readme.txt") {
                file.delete()
        }
    }
    List<String> params
    bamFilesToTest(bamFilesDir).each { String bamFilePath ->
        Map<String, String> parameters = [
            "bamFilepath": bamFilePath,
            "outputDir": processedBamDir(bamFilePath, latestOutputDir),
            "depthOfCoverageFilename": coDepthOfCoverageFilepath(bamFilePath, latestOutputDir),
            "chromosomeDiffDataFilename": coDiffDataChromosomesFilepath(bamFilePath, latestOutputDir),
            "flagstatsFilename": coFlagstatsFilepath(bamFilePath, latestOutputDir),
            "insertSizeDataFilename": coInsertSizesDataFilepath(bamFilePath, latestOutputDir),
            "coverageTableFilename": coCoverageTableFilepath(bamFilePath, latestOutputDir)
        ]
        params = parameters.values() as List<String>
        String cmd = "${dataRepositoryDir}/generateData.sh"
        params.each { String parameter ->
            cmd += " ${parameter}"
        }
        println "job submitted : "+ cmd.execute().text
    }
}

/**
 * Compare generated test data against the Gold Standard data
 *  - Compares results from the single files containing statistics (JSON format) against four different files from the CO Group
 *  - Compares the coverage counts file (tabular data)
 *  - The insert sizes files are not compared directly (the application only generate absolute values so the list of values cannot be compared directly) but some of the results like the mean and the standard deviation contained at the
 *  JSON format are compared with the results from the CO group
 */
task comparisonTest << {
    bamFilesToTest(bamFilesDir).each { String bamFilePath ->
        // comparing Json file statistics
        String dmJson = statisticsFilePath(bamFilePath, resultsDir)
        String coDepthOfCoverage = coDepthOfCoverageFilepath(bamFilePath, latestOutputDir)
        String coDiffChromosomes = coDiffChromosomesFilepath(bamFilePath, latestOutputDir)
        String coFlagstats = coFlagstatsFilepath(bamFilePath, latestOutputDir)
        String coInsertSizes = coInsertSizesQcValuesFilepath(bamFilePath, latestOutputDir)
        compareStats(dmJson, coDepthOfCoverage, coDiffChromosomes, coFlagstats, coInsertSizes)
        // comparing coverage counts file
        String dmCoverageTable = coverageFilePath(bamFilePath, resultsDir)
        String coCoverageTable = coCoverageTableFilepath(bamFilePath, latestOutputDir)
        compareCoverage(dmCoverageTable, coCoverageTable)
    }
}

//private String branchName() {
//    String branchName = System.getenv("GIT_BRANCH")
//    if (!branchName) {
//        // not specified through environment - try to resolve through git
//        ext.proc = "git symbolic-ref HEAD".execute()
//        proc.waitFor()
//        branchName = proc.in.text
//    }
//    // remove git path structure and appended line feed
//    if (branchName.contains("/")) {
//        return branchName.substring(branchName.lastIndexOf("/") + 1, branchName.length() - 1)
//    }
//    return branchName
//}

/**
 * Retrieves the list of bam files from the representative bam files directory
 * @param bamFilesDir Directory with representative bam files
 * @return A list of bam files contained at the directory
 */
private List<String> bamFilesToTest(String bamFilesDir) {
    final String BAM_FILES_EXTENSION  = ".bam"
    List<String> list = []
    new File(bamFilesDir).eachFileRecurse(FileType.FILES) { File fileObj ->
        String file = fileObj.getCanonicalPath()
//        if (file.substring(file.length() - BAM_FILES_EXTENSION.length(), file.length()) == BAM_FILES_EXTENSION) {
        if (file.endsWith(BAM_FILES_EXTENSION)) {
            list << file
        }
    }
    return list
}

/**
 * Path to the Statistics data file generated by the application
 */
private String statisticsFilePath(String bamFilePath, String resultsPath) {
    return "${processedBamDir(bamFilePath, resultsPath)}/stats.json"
}

/**
 * Path to the coverage data file generated by the application
 */
private String coverageFilePath(String bamFilePath, String resultsPath) {
    return "${processedBamDir(bamFilePath, resultsPath)}/coverage.tsv"
}

/**
 * Path to the insert size data file generated by the application
 */
private String insertSizeDistributionFilePath(String bamFilePath, String resultsPath) {
    return "${processedBamDir(bamFilePath, resultsPath)}/insertSize.tsv"
}

/**
 * Path to the data file generated by the CO scripts
 */
private String coDepthOfCoverageFilepath(String bamFilePath, String goldStandardRepository) {
    String bamFileName = bamFileName(bamFilePath)
    String processedBamDir = processedBamDir(bamFilePath, goldStandardRepository)
    String coDepthOfCoverage = "${processedBamDir}/${bamFileName}_DepthOfCoverage_Genome.txt"
    return coDepthOfCoverage
}

/**
 * Path to the data file generated by the CO scripts
 * The path to this file has to be passed as parameter although this is not the file we are interested in.
 * (The filename we are interested in, is hardcoded at the CO group script and should be obtained through the "coDiffChromosomesFilepath" method)
 */
private String coDiffDataChromosomesFilepath(String bamFilePath, String goldStandardRepository) {
    String bamFileName = bamFileName(bamFilePath)
    String goldStandardBamDir = processedBamDir(bamFilePath, goldStandardRepository)
    String coDiffChromosomes = "${goldStandardBamDir}/${bamFileName}.txt"
    return coDiffChromosomes
}

/**
 * The filename is hardcoded in CO scripts and this method is used to match whatever is hardcoded at "plotStructuralVariation.R"
 * The scripts do not have this path as parameter so this method is needed only to know where the file is being written. (after the script with the hardcoded filename is executed)
 * (This method is highly coupled with the method "coDiffDataChromosomesFilepath")
 */
private String coDiffChromosomesFilepath(String bamFilePath, String goldStandardRepository) {
    String bamFileName = bamFileName(bamFilePath)
    String goldStandardBamDir = processedBamDir(bamFilePath, goldStandardRepository)
    return "${goldStandardBamDir}/${bamFileName}.png_qcValues.txt"
}

private String coFlagstatsFilepath(String bamFilePath, String goldStandardRepository) {
    String bamFileName = bamFileName(bamFilePath)
    String goldStandardBamDir = processedBamDir(bamFilePath, goldStandardRepository)
    String coFlagstats = "${goldStandardBamDir}/${bamFileName}_flagstats.txt"
    return coFlagstats
}

private String coInsertSizesDataFilepath(String bamFilePath, String goldStandardRepository) {
    String bamFileName = bamFileName(bamFilePath)
    String goldStandardBamDir = processedBamDir(bamFilePath, goldStandardRepository)
    String coInsertSizes = "${goldStandardBamDir}/${bamFileName}_insertsizes.txt"
    return coInsertSizes
}

private String coInsertSizesQcValuesFilepath(String bamFilePath, String goldStandardRepository) {
    String insertSizesDataFilepath = coInsertSizesDataFilepath(bamFilePath, goldStandardRepository)
    return "${insertSizesDataFilepath}.png_qcValues.txt"
}

private String coCoverageTableFilepath(String bamFilePath, String goldStandardRepository) {
    String bamFileName = bamFileName(bamFilePath)
    String goldStandardBamDir = processedBamDir(bamFilePath, goldStandardRepository)
    String coCoverageTable = "${goldStandardBamDir}/${bamFileName}_coverageTable.txt"
    return coCoverageTable
}

private String processedBamDir(String bamFilePath, String processedDir) {
    String bamFileName = bamFileName(bamFilePath)
    String bamDir = "${processedDir}/${bamFileName}"
    return bamDir
}

private String bamFileName(String bamFilePath) {
    return bamFilePath.substring(bamFilePath.lastIndexOf("/") + 1, bamFilePath.length())
}

/**
 * Set of file parameters used at the QA jar
 * Some parameters are hardcoded in a sh script so this values are used to avoid duplication
 */
private Map<String, String> fileParameters(String bamFile, resultsPath) {
    Map<String, String> fileParameters = [
        "StatisticsFilePath": statisticsFilePath(bamFile, resultsPath),
        "CoverageFilePath": coverageFilePath(bamFile, resultsPath),
        "InsertSizeFilePath": insertSizeDistributionFilePath(bamFile, resultsPath),
        "overrideOutput": "true"
    ]
    return fileParameters
}

/**
 * Set of numerical parameters used by the application
 *
 * Some parameters are hardcoded in a shell script so these values are parsed from those files to avoid declaration duplication
 * Files parsed and corresponding hardcoded parameters :
 *
 *  - genomeCoverage.sh
 *          MinAlignedRecordLength
 *
 *  - runtimeConfig.sh
 *          MinMeanBaseQuality
 *          WindowSize
 *
 * param srcDir Directory where the files containing hardcoded parameters are located
 * return A Map containing the parameters parsed and correponding value
 */
private Map<String, String> numericalParameters(String srcDir) {
    Map<String, String> runtimeConfigParameters = parseCORuntimeConfigParameters(srcDir)
    Map<String, String> genomeCoverageParameters = parseCOGenomeCoverageParameters(srcDir)
    Map<String, String> numericalParams = [
        "allChromosomeName": "ALL",
        "MinAlignedRecordLength": genomeCoverageParameters.get("minReadLength"),
        "MinMeanBaseQuality": runtimeConfigParameters.get("BASE_QUALITY_CUTOFF"),
        "MappingQuality": "0",
        "CoverageMappingQualityThreshold": "1",
        "WindowSize": ((runtimeConfigParameters.get("WINDOW_SIZE") as long) * 1000).toString(),
        "InsertSizeCountHistogramBin": "10",
        "testMode": "true"
    ]
    return numericalParams
}

/**
 * Retrieves a Map of hardcoded parameters from the source code of genomeCoverage.sh
 * Parameters hardcoded:
 * The minimum read length
 * param srcDir Directory where the file containing hardcoded parameters are located
 */
private Map<String, String> parseCOGenomeCoverageParameters(String srcDir) {
    String filePath = "${srcDir}/genomeCoverage.sh"
    File file = new File(filePath)
    String key = "minReadLength"
    String match = file.text.find("--${key}=[0-9]+")
    String value = match.split("=").last()
    return [(key): value]
}

/**
 * Retrieves a Map of parameters from runtimeConfig.sh (script from CO group that contains many properties declared)
 * param srcDir Directory where the file containing hardcoded parameters are located
 */
private Map<String, String> parseCORuntimeConfigParameters(String srcDir) {
    String runtimeConfigFilePath = "${srcDir}/runtimeConfig.sh"
    File configFile = new File(runtimeConfigFilePath)
    Map<String, String>  parameters = [:]
    configFile.eachLine { String line ->
        String[] keyValue = line.split("=")
        parameters.put(keyValue.first(),keyValue.last())
    }
    return parameters
}

/**
 * Compare results between Json file from Data management and set of Files from Computer Oncology
 */
private void compareStats(String JsonFromDM, String coverageFromCO, String percentAberrationsFromCO, String flagStatsFromCO, String insertSizeFromCO) {
    // TODO Use logging in gradle..
    println ""
    println "Comparing for ${JsonFromDM}"
    println ""
    ChromosomeStatistic chromosomeStatistic = overallChromosomeStatistic(JsonFromDM)
    compareReadsMappedDiffChr(chromosomeStatistic, percentAberrationsFromCO)
    compareDepthOfCoverage(chromosomeStatistic, coverageFromCO)
    compareFlagstats(chromosomeStatistic, flagStatsFromCO)
    compareInsertSizes(chromosomeStatistic, insertSizeFromCO)
}

private void compareCoverage(String dmCoverageTable, String coCoverageTable) {
    // TODO Use logging in gradle..
    println ""
    println "Comparing for ${dmCoverageTable}"
    println ""
    File dmCoverageTableFile = new File(dmCoverageTable)
    File coCoverageTableFile = new File(coCoverageTable)
    assertEquals("Coverage Table file", coCoverageTableFile, dmCoverageTableFile)
}

private void compareReadsMappedDiffChr(ChromosomeStatistic chromosomeStatistic, String readsMappedDiffChrFilepath) {
    // Capturing single result from this file from CO group
    File diffsReadMappedDiffChr = new File(readsMappedDiffChrFilepath)
    double percentOfReadsMappedDiffChr = diffsReadMappedDiffChr.readLines().first() as double
    double dmgPercentOfReadsMappedDiffChr = chromosomeStatistic.endReadAberration/chromosomeStatistic.totalMappedReadCounter * 100
    DecimalFormat twoDecimalFormat = new DecimalFormat("#.##")
    double roundDmgPercentOfReadsMappedDiffChr = twoDecimalFormat.format(dmgPercentOfReadsMappedDiffChr) as double
    assertEquals("percentOfReadsMappedDiffChr", roundDmgPercentOfReadsMappedDiffChr, percentOfReadsMappedDiffChr)
}

private void compareDepthOfCoverage(ChromosomeStatistic chromosomeStatistic, String depthOfCoverageFilepath) {
    // Creating a map of the results from the coverage data file from CO group
    File depthOfCoverage = new File(depthOfCoverageFilepath)
    List<String> depthOfCoverageLines = depthOfCoverage.readLines()
    String TAB_SEPARATOR = "\t"
    List<String> keys = depthOfCoverageLines.first().split(TAB_SEPARATOR)
    List<String> values = depthOfCoverageLines.last().split(TAB_SEPARATOR)
    Map depthOfCoverageDataForALL = [:]
    keys.eachWithIndex  { String key, int index ->
        depthOfCoverageDataForALL.put(key, values[index])
    }
    String coverage = depthOfCoverageDataForALL.get("#QC bases/#total bases")
    long total_bases = coverage.split(" / ")[1] as long
    assertEquals("referenceLength", chromosomeStatistic.referenceLength, total_bases)
    assertEquals("duplicateR1", chromosomeStatistic.duplicateR1, depthOfCoverageDataForALL.get("#duplicates read1 (excluded from coverage analysis)") as long)
    assertEquals( "duplicateR2", chromosomeStatistic.duplicateR2, depthOfCoverageDataForALL.get("#duplicates read2 (excluded from coverage analysis)") as long)
    assertEquals("#incorrect proper pair", chromosomeStatistic.properPairStrandConflict, depthOfCoverageDataForALL.get("#incorrect proper pair") as long)
    double percentIncorrectPEOrientation = chromosomeStatistic.referenceAgreementStrandConflict/chromosomeStatistic.referenceAgreement * 100
    DecimalFormat threeDecimalFormat = new DecimalFormat("#.###")
    double roundPercentIncorrectPEOrientation = threeDecimalFormat.format(percentIncorrectPEOrientation) as double
    assertEquals("%incorrect PE orientation", roundPercentIncorrectPEOrientation, depthOfCoverageDataForALL.get('%incorrect PE orientation') as double)
    assertEquals("mappedQualityLongR1", chromosomeStatistic.mappedQualityLongR1, depthOfCoverageDataForALL.get('mapq>0,BaseQualityMedian>=basequalCutoff read1') as long)
    assertEquals("mappedQualityLongR2", chromosomeStatistic.mappedQualityLongR2, depthOfCoverageDataForALL.get('mapq>0,BaseQualityMedian>=basequalCutoff read2') as long)
    long qc_bases = coverage.split("/").first() as long
    assertEquals("qcBasesMapped", chromosomeStatistic.qcBasesMapped, qc_bases)
    assertEquals("mappedLowQualityR1", chromosomeStatistic.mappedLowQualityR1, depthOfCoverageDataForALL.get('mapq>0,BaseQualityMedian<basequalCutoff read1') as long)
    assertEquals("mappedLowQualityR2", chromosomeStatistic.mappedLowQualityR2, depthOfCoverageDataForALL.get('mapq>0,BaseQualityMedian<basequalCutoff read2') as long)
    assertEquals("notMappedR1", chromosomeStatistic.notMappedR1, depthOfCoverageDataForALL.get('mapq=0 read1') as long)
    assertEquals("notMappedR2", chromosomeStatistic.notMappedR2, depthOfCoverageDataForALL.get('mapq=0 read2') as long)
}

private void compareFlagstats(ChromosomeStatistic chromosomeStatistic, String flagstatsFilepath) {
    // Creating a map of the results from the flagstats data file from CO group
    File flagsStatsFile = new File(flagstatsFilepath)
    //TODO qcFailedReads not considered
    List flagStatsLabels = [
        "totalReadCounter", "duplicates", "totalMappedReadCounter", "pairedInSequencing", "pairedRead1" ,"pairedRead2", "properlyPaired", "withItselfAndMateMapped", "singletons", "withMateMappedToDifferentChr", "withMateMappedToDifferentChrMaq"]
    Map flagStatsData = [:]
    flagsStatsFile.eachWithIndex { String line, int lineIndex ->
        flagStatsData.put(flagStatsLabels[lineIndex],  line.split().first())
    }
    assertEquals("totalReadCounter", chromosomeStatistic.totalReadCounter, flagStatsData.get('totalReadCounter') as long)
    assertEquals("duplicates", chromosomeStatistic.duplicates, flagStatsData.get('duplicates') as long)
    assertEquals("totalMappedReadCounter", chromosomeStatistic.totalMappedReadCounter, flagStatsData.get('totalMappedReadCounter') as long)
    assertEquals("pairedInSequencing", chromosomeStatistic.pairedInSequencing, flagStatsData.get('pairedInSequencing') as long)
    assertEquals("pairedRead1", chromosomeStatistic.pairedRead1, flagStatsData.get('pairedRead1') as long)
    assertEquals("pairedRead2", chromosomeStatistic.pairedRead2, flagStatsData.get('pairedRead2') as long)
    assertEquals("properlyPaired", chromosomeStatistic.properlyPaired, flagStatsData.get('properlyPaired') as long)
    assertEquals("withItselfAndMateMapped", chromosomeStatistic.withItselfAndMateMapped, flagStatsData.get('withItselfAndMateMapped') as long)
    assertEquals("singletons", chromosomeStatistic.singletons, flagStatsData.get('singletons') as long)
    assertEquals("withMateMappedToDifferentChr", chromosomeStatistic.withMateMappedToDifferentChr, flagStatsData.get('withMateMappedToDifferentChr') as long)
    assertEquals("withMateMappedToDifferentChrMaq", chromosomeStatistic.withMateMappedToDifferentChrMaq, flagStatsData.get('withMateMappedToDifferentChrMaq') as long)
}

private void compareInsertSizes(ChromosomeStatistic chromosomeStatistic, String insertSizeFilepath) {
    File insertSizeFile = new File(insertSizeFilepath)
    List<String> insertSizeValues = insertSizeFile.readLines()
    int insertSizeMedian = insertSizeValues.first() as int
    double insertSizeSDpercent = insertSizeValues.last() as double
    assertEquals("insertSizeMedian",  chromosomeStatistic.insertSizeMedian, insertSizeMedian)
    double dmInsertSizeSDpercent = Math.round(chromosomeStatistic.insertSizeSD / chromosomeStatistic.insertSizeMedian * 100)
    assertEquals("dmInsertSizeSDpercent", dmInsertSizeSDpercent, insertSizeSDpercent)
}

/**
 * Retrieves an object with statistitics for the overall chromosomes
 * @param statisticsFilePath Path to the statistics Json file
 * @return ChromosomeStatistic
 */
private ChromosomeStatistic overallChromosomeStatistic(String statisticsFilepath) {
    String ALL = '"ALL":'
    File results = new File(statisticsFilepath)
    // TODO there should be a better way to extract a collection of results from the JSON file..
    // couldn't make it work with gson, so I am simply parsing before using gson to generate just the the object used (ChromosomeStatistic for ALL)
    int indexOfChromosomeALL = results.text.indexOf(ALL) + ALL.length()
    int lastIndexOfCollectionOfChromosomes = results.text.lastIndexOf('}')
    String chromosomeAll = results.text.substring(indexOfChromosomeALL, lastIndexOfCollectionOfChromosomes)
    ChromosomeStatistic chromosomeStatistic = (new Gson()).fromJson(chromosomeAll, ChromosomeStatistic.class)
    return chromosomeStatistic
}

/**
 * TODO (This is a Hack.. Do not know how to submit a shell script command without creating a file)
 * Creates a temporary shell script to be used to submit jobs to the cluster
 */
private String createShellScript(String path, String command) {
    int pause = 5000
    // to avoid overwritting of file while is being used elsewhere..
    sleep pause
    println "Created file ${path}"
    File file = new File(path)
    file.delete()
    file.createNewFile()
    file << command
    sleep pause
    return path
}

/*
 * Helper method.. Since we are still heavy using this to validate our results we may want to visualize the entire set of fields
 * So instead of using assertEquals of GroovyTestCase that throws exceptions on failure and does not show anything else, I created this method with the same signature.. (Can be easier replaced in future)
 */
private void assertEquals(description, dm, co) {
    if (dm == co) {
        println "SUCCESS ${description} : ${dm}"
    } else {
        println "FAILED ${description} : ${dm} != ${co}"
    }
}

/*
 * Helper method.. Since we are still heavy using this to validate our results we may want to visualize the entire set of fields
 * So instead of using assertEquals of FileAssert that throws exceptions on failure and does not show anything else, I created this method with the same signature.. (Can be easier replaced in future)
 */
private void assertEquals(String description, File dm, File co) {
    try {
        FileAssert.assertEquals("FAILURE", coCoverageTableFile, dmCoverageTableFile)
        println "SUCESS"
    } catch (e) {
        println "FAILURE Coverage table : Differences between \nDM : ${dm.canonicalPath}\nCO : ${co.canonicalPath}"
    }
}

/**
 * Hack to implement the parsing of JSON file (could not use the compiled class of the application since it may not be generated at the time the script is executed)
 * (This dependency could be removed if we do not use the gson library for the comparison at this script..)
 */
class ChromosomeStatistic {

    String chromosomeName

    long referenceLength
    long duplicateR1
    long duplicateR2
    long properPairStrandConflict
    long referenceAgreement
    long referenceAgreementStrandConflict
    long mappedQualityLongR1
    long mappedQualityLongR2
    long qcBasesMapped
    long mappedLowQualityR1
    long mappedLowQualityR2
    long mappedShortR1
    long mappedShortR2
    long notMappedR1
    long notMappedR2

    long endReadAberration
    long totalReadCounter
    long qcFailedReads
    long duplicates
    long totalMappedReadCounter
    long pairedInSequencing
    long pairedRead2
    long pairedRead1
    long properlyPaired
    long withItselfAndMateMapped
    long withMateMappedToDifferentChr
    long withMateMappedToDifferentChrMaq
    long singletons

    double insertSizeMedian
    double insertSizeMean
    double insertSizeSD
    double insertSizeRMS
}
